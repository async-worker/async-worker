# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, B2W Digital
# This file is distributed under the same license as the Asyncworker
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Asyncworker \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-18 14:23-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../userguide/handlers/http.rst:2
msgid "HTTP"
msgstr ""

#: ../../userguide/handlers/http.rst:6
msgid ""
"Aqui mostraremos como escrever um handler que é estimulado através de "
"requisições HTTP."
msgstr ""

#: ../../userguide/handlers/http.rst:9
msgid ""
"Um handler é simplesmete uma corotina que recebe um request "
"(``aiohttp.web.Request``) e retorna uma response "
"(``aiohttp.web.Response``). Essa corotina passa a ser um handler "
"\"asyncworker\" quando é decorada com ``@app.route()``, onde ``app`` é "
"uma instância de ``asyncworker.App``."
msgstr ""

#: ../../userguide/handlers/http.rst:11
msgid "Vejamos um handler bem simples que apenas retorna ``HTTP 200 OK``."
msgstr ""

#: ../../userguide/handlers/http.rst:20
msgid ""
"Como recebemos um request do aiohttp, podemos fazer o que for preciso "
"para extrair dele as informações que precisarmos. Para mais detalhes, "
"veja a doc do aiohttp: https://docs.aiohttp.org/en/stable/web.html"
msgstr ""

#: ../../userguide/handlers/http.rst:24
msgid "Parametrização do decorator route() para handlers HTTP"
msgstr ""

#: ../../userguide/handlers/http.rst:26
msgid ""
"Para um handler HTTP deveremos passar os seguintes parametros para o "
"decorator ``route()``:"
msgstr ""

#: ../../userguide/handlers/http.rst:28
msgid ""
"Lista de paths que devem estar na Request HTTP para que esse handler seja"
" chamado;"
msgstr ""

#: ../../userguide/handlers/http.rst:29
msgid "``type=RouteTypes.HTTP``"
msgstr ""

#: ../../userguide/handlers/http.rst:30
msgid "``methods`` sendo uma lista de métodos HTTP permitidos para esse handler"
msgstr ""

#: ../../userguide/handlers/http.rst:33
msgid "ENVs para escolher a porta e o IP onde o server http estará escutando"
msgstr ""

#: ../../userguide/handlers/http.rst:36
msgid ""
"Por padrão, fazemos o binding em ``127.0.0.1``, porta ``8080``, mas isso "
"pode ser alterado com as envvars ``ASYNCWORKER_HTTP_HOST`` e "
"``ASYNCWORKER_HTTP_PORT``, respectivamente."
msgstr ""

#: ../../userguide/handlers/http.rst:41
msgid "Aplicando decorators customizados a um handler HTTP"
msgstr ""

#: ../../userguide/handlers/http.rst:43
msgid ""
"É possível escrever seus próprios decorators e aplicá-los a seus "
"handlers, junto com o decorator ``@app.route``. No entando temos algumas "
"regras:"
msgstr ""

#: ../../userguide/handlers/http.rst:45
msgid ""
"O decorator ``@app.route()`` deve estar sempre no topo da lista de "
"decorators de um handler;"
msgstr ""

#: ../../userguide/handlers/http.rst:46
msgid ""
"Os decorators intermediários devem sempre usar a função "
":py:func:`asyncworker.routes.call_http_handler()` no momento de chamar o "
"objeto que estão decorando;"
msgstr ""

#: ../../userguide/handlers/http.rst:47
msgid "A inner function retornada pelo decorator deve ser uma corotina;"
msgstr ""

#: ../../userguide/handlers/http.rst:48
msgid "A inner function deve receber apenas ``aiohttp.web.Request``;"
msgstr ""

#: ../../userguide/handlers/http.rst:49
msgid "Essa inner function não deve ser decorada com ``@functools.wraps()``."
msgstr ""

#: ../../userguide/handlers/http.rst:52
msgid "Um exemplo simples de decorator:"
msgstr ""

#: ../../userguide/handlers/http.rst:64
msgid ""
"A razão para isso é que o asyncworker permite que um handler receba "
"parametros dinâmicos (mais sobre isso adiante) e a função "
"``call_http_handler()`` é quem tem ciência disso e saberá fazer a "
"resolução correta dos parametros necessários para que o handler seja "
"corretamente chamado."
msgstr ""

#: ../../userguide/handlers/http.rst:66
msgid "Esse decorator poderia ser aplicado a um handler assim:"
msgstr ""

#: ../../userguide/handlers/http.rst:77
msgid "Handlers que são objetos callable"
msgstr ""

#: ../../userguide/handlers/http.rst:81
msgid ""
"É possível também escrever handlers como objetos que são callables, ou "
"seja, possuem o método ``async def __call__()``. Importante notar que a "
"assinatura do método ``__call__()`` segue as mesmas regras da assinatura "
"de uma corotina decorada com o ``@app.route()``."
msgstr ""

#: ../../userguide/handlers/http.rst:83
msgid ""
"Esses handlers são especialmente úteis quando você precisa guardar algum "
"tipo de contexto e não quer fazer isso com variáveis globais no nível do "
"módulo."
msgstr ""

#: ../../userguide/handlers/http.rst:85
msgid "Um exemplo de um handler:"
msgstr ""

#: ../../userguide/handlers/http.rst:94
msgid ""
"Importante notar que como estamos lidando com um objeto ele precisará ser"
" instanciado antes de ser usado e isso significa que não vamos poder "
"decorá-lo da mesma forma que decoramos handlers que são apenas uma "
"corotina. Um código desse gera erro de sintaxe:"
msgstr ""

#: ../../userguide/handlers/http.rst:107
msgid ""
"Por isso esses handlers precisam ser registrados chamando o decorator "
"manualmente, assim:"
msgstr ""

#: ../../userguide/handlers/http.rst:121
msgid "Handlers que recebem mais do que apenas Request"
msgstr ""

#: ../../userguide/handlers/http.rst:125
msgid ""
"O asyncworker permite que um handler receba quaisquer prametros. Para "
"isso a assinatura do handler deve conter typehints em todos os "
"parametros. Isso faz com que o asyncowker consiga fazer a resolução "
"desses prametros e consiga chamar o handler corretamente."
msgstr ""

#: ../../userguide/handlers/http.rst:127
msgid ""
"Todas as instancias de ``aiohttp.web.Request`` recebem um atributo "
"chamado ``types_registry`` que é do tipo "
":py:class:`asyncworker.types.registry.TypesRegistry`. Para que um "
"parametro possa ser passado a um handler ele deve ser adicionado a esse "
"registry do request."
msgstr ""

#: ../../userguide/handlers/http.rst:129
msgid ""
"Um exemplo de como popular esse registry é através de um decorator "
"aplicado diretamente ao um handler. Vejamos um exemplo:"
msgstr ""

#: ../../userguide/handlers/http.rst:156
msgid ""
"Aqui o decorator ``auth_required()`` é responsável por fazer a "
"autenticação, pegando dados do Request e encontrando um usuário válido. "
"Se um usuário não puder ser encontrado, retorna "
"``HTTPStatus.UNAUTHORIZED``. Se um usuário autenticar com sucesso, apenas"
" adiciona o objeto user (que é do tipo ``User``) no registry que está no "
"request. Isso é o suficiente para que o handler, quando for chamado, "
"receba diretamente esse user já autenticado."
msgstr ""

